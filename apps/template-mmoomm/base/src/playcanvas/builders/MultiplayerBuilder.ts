// Multiplayer Builder for MMOOMM Templates
import type { IFlowData, BuildOptions } from '../../common/types'
import { HandlerManager } from '../handlers/HandlerManager'
import { createMMOOMMBuilderSystemsManager } from '../handlers/shared/builderSystems'
import { generateShipLogic } from '../handlers/EntityHandler/entityTypes/ship'

/**
 * Multiplayer Builder
 * Handles Colyseus integration and multiplayer scene generation
 * Uses HandlerManager for consistent UPDL processing with network adaptations
 */
const DEBUG = !!(((globalThis as any)?.DEBUG_MULTIPLAYER) || ((globalThis as any)?.DEBUG_RENDER))

export class MultiplayerBuilder {
    private handlerManager: HandlerManager

    constructor() {
        this.handlerManager = new HandlerManager()
        if (DEBUG) console.log('[MultiplayerBuilder] Initialized with HandlerManager')
    }

    /**
     * Build multiplayer MMOOMM scene with Colyseus integration
     */
    async build(flowData: IFlowData, options: BuildOptions = {}): Promise<string> {
        if (DEBUG) console.log('[MultiplayerBuilder] Building multiplayer MMOOMM scene')

        try {
            // Process UPDL flow data for multiplayer using HandlerManager
            const multiplayerData = this.handlerManager.processForMultiplayer(flowData)

            // Generate auth screen HTML from processed data
            const authScreenHTML = this.generateAuthScreen(multiplayerData.authScreenData)

            // Generate game scene script from processed data (reusing SP systems)
            const gameScript = this.generateGameSceneWithSystems(multiplayerData)

            // Generate Colyseus client integration
            const colyseusScript = this.generateColyseusClient(multiplayerData.serverConfig)

            const combinedScript = [
                '// Multiplayer MMOOMM Scene - Generated by Universo Platformo',
                gameScript,
                colyseusScript
            ].join('\n')

            // Use systems manager for complete HTML generation with multiplayer-specific configuration
            const systems = this.createMultiplayerSystemsManager()

            // Add Colyseus library to options for HTML generation
            const multiplayerOptions = {
                ...options,
                librarySources: ['https://unpkg.com/colyseus.js@0.16.4/dist/colyseus.js'],
                additionalHTML: authScreenHTML
            }

            const completeHTML = systems.generateCompleteHTML(combinedScript, multiplayerOptions)

            return completeHTML

        } catch (error) {
            console.error('[MultiplayerBuilder] Build error:', error)
            // Use error scene from systems manager (includes app.start())
            const systems = this.createMultiplayerSystemsManager()
            return systems.generateErrorScene(options)
        }
    }

    /**
     * Generate authentication screen for multiplayer mode
     */
    private generateAuthScreen(authScreenData: any): string {
        return `
        <!-- Multiplayer Authentication Screen -->
        <div id="multiplayer-auth-screen" style="
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            font-family: Arial, sans-serif;
        ">
            <div style="
                background: rgba(255,255,255,0.1);
                padding: 40px;
                border-radius: 15px;
                text-align: center;
                color: white;
                max-width: 400px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            ">
                <h2 style="margin: 0 0 20px 0; font-size: 24px;">
                    ${authScreenData?.title || 'Добро пожаловать в Universo MMOOMM'}
                </h2>
                <p style="margin: 0 0 30px 0; font-size: 16px; opacity: 0.9;">
                    ${authScreenData?.description || 'Введите ваше имя для входа в многопользовательскую игру:'}
                </p>
                <input
                    type="text"
                    id="player-name-input"
                    placeholder="${authScreenData?.placeholder || 'Ваше имя'}"
                    style="
                        width: 100%;
                        padding: 15px;
                        margin: 20px 0;
                        border: none;
                        border-radius: 8px;
                        font-size: 16px;
                        box-sizing: border-box;
                        background: rgba(255,255,255,0.9);
                        color: #333;
                    "
                    maxlength="20"
                    required
                >
                <button
                    id="join-game-btn"
                    style="
                        width: 100%;
                        padding: 15px;
                        background: #4CAF50;
                        color: white;
                        border: none;
                        border-radius: 8px;
                        font-size: 16px;
                        cursor: pointer;
                        transition: background-color 0.3s;
                    "
                >
                    Войти в игру
                </button>
                <div id="connection-status" style="
                    margin-top: 15px;
                    font-size: 14px;
                    opacity: 0.8;
                    display: none;
                ">
                    Подключение к серверу...
                </div>
            </div>
        </div>

        <script>
        // Authentication logic for multiplayer mode
        document.getElementById('join-game-btn').addEventListener('click', function() {
            const nameInput = document.getElementById('player-name-input');
            const name = nameInput.value.trim();

            if (name.length < 2) {
                alert('Имя должно содержать минимум 2 символа');
                return;
            }

            playerName = name;
            document.getElementById('connection-status').style.display = 'block';
            document.getElementById('join-game-btn').disabled = true;
            document.getElementById('join-game-btn').textContent = 'Подключение...';

            // Connect to multiplayer server
            connectToMultiplayerServer(playerName);
        });

        // Enter key support
        document.getElementById('player-name-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                document.getElementById('join-game-btn').click();
            }
        });
        </script>
        `
    }

    /**
     * Generate game scene from processed multiplayer data using systems manager
     */
    private generateGameSceneWithSystems(multiplayerData: any): string {
        // Combine all generated scripts from handlers
        const spaceScripts = multiplayerData.spaces.map((space: any) => space.script || '').join('\n')
        const entityScripts = multiplayerData.entities.map((entity: any) => entity.script || '').join('\n')
        const componentScripts = multiplayerData.components.map((component: any) => component.script || '').join('\n')
        const eventScripts = multiplayerData.events.map((event: any) => event.script || '').join('\n')
        const actionScripts = multiplayerData.actions.map((action: any) => action.script || '').join('\n')

        // Generate network entities data for Colyseus synchronization
        const networkEntitiesData = JSON.stringify(multiplayerData.networkEntities)
        const playerSpawnPoint = multiplayerData.playerSpawnPoint

        return `
        // Multiplayer Game Scene - Generated from UPDL Space (with SP systems integration)
        console.log('[MMOOMM] Loading multiplayer scene with', ${multiplayerData.entities.length}, 'entities');
        console.log('[MMOOMM] Network entities:', ${multiplayerData.networkEntities.length});

        // Store network entities data for Colyseus
        window.networkEntitiesData = ${networkEntitiesData};
        window.playerSpawnPoint = ${JSON.stringify(playerSpawnPoint)};
        
        // Prevent SpaceControls initialization until connected to server
        window.multiplayerMode = true;
        window.connectedToServer = false;
        // Disable verbose logs for components/entities by default
        window.DEBUG_MULTIPLAYER = false;
        
        // Override initializeSpaceControls to prevent auto-initialization in multiplayer
        const originalInitializeSpaceControls = window.initializeSpaceControls;
        window.initializeSpaceControls = function() {
            if (window.multiplayerMode && !window.connectedToServer) {
                console.log('[Multiplayer] Delaying SpaceControls initialization until server connection');
                return;
            }
            if (originalInitializeSpaceControls) {
                originalInitializeSpaceControls();
            }
        };

        // Initialize space configuration
        ${spaceScripts}

        // Create entities from UPDL (with network adaptations)
        ${entityScripts}

        // Attach components
        ${componentScripts}

        // Setup events (with network broadcasting)
        ${eventScripts}

        // Setup actions (with network synchronization)
        ${actionScripts}

        // Start application render loop
        app.start();

        console.log('[MMOOMM] Multiplayer game scene ready');
        `
    }



    /**
     * Generate Colyseus client integration
     */
    private generateColyseusClient(serverConfig: any): string {
        return `
        // Colyseus client for multiplayer mode (0.16.x compatible)
        let colyseusClient = null;
        let room = null;
        let playerName = '';
        let localPlayerId = null;
        let networkUpdateHandler = null; // ensure single subscription
        let SPACE_CONTROLS_INITIATED = false; // guard SpaceControls initialization
        const DEBUG_MP = false; // disable verbose multiplayer logs by default

        // Server configuration from HandlerManager
        const serverConfig = ${JSON.stringify(serverConfig)};

        async function connectToMultiplayerServer(name) {
            try {
                console.log('[Multiplayer] Connecting to server:', serverConfig.host + ':' + serverConfig.port);
                console.log('[Multiplayer] Player name:', name);

                // Create Colyseus client
                const protocol = serverConfig.protocol || 'ws';
                const serverUrl = protocol + '://' + serverConfig.host + ':' + serverConfig.port;
                
                colyseusClient = new Colyseus.Client(serverUrl);
                
                // Prepare entity data for server
                const entityData = window.networkEntitiesData || [];
                if (DEBUG_MP) console.log('[Multiplayer] Sending entity data to server:', {
                    count: entityData.length,
                    entities: entityData.map(e => ({
                        id: e.id,
                        type: e.type,
                        entityType: e.entityType,
                        position: e.position,
                        components: e.components?.length || 0
                    }))
                });

                // Join or create room with enhanced entity data
                room = await colyseusClient.joinOrCreate(serverConfig.roomName || 'mmoomm', {
                    playerName: name,
                    entities: entityData // Changed from networkEntities to entities to match server expectation
                });

                localPlayerId = room.sessionId;
                console.log('[Multiplayer] Connected successfully! Session ID:', localPlayerId);

                // Set connection flag
                window.connectedToServer = true;

                // Initialize SpaceControls since we're connected (guarded)
                safeInitSpaceControls();

                // Setup Colyseus 0.16.x event handlers
                setupColyseusHandlers();

                // Hide auth screen
                document.getElementById('multiplayer-auth-screen').style.display = 'none';
                
            } catch (error) {
                console.error('[Multiplayer] Connection error:', error);
                alert('Ошибка подключения к серверу: ' + error.message);
                
                // Reset auth screen
                document.getElementById('join-game-btn').disabled = false;
                document.getElementById('join-game-btn').textContent = 'Войти в игру';
                document.getElementById('connection-status').style.display = 'none';
            }
        }

        // Helper: extract visual config for player ship from UPDL networkEntities
        function getPlayerShipVisual() {
            const data = Array.isArray(window.networkEntitiesData) ? window.networkEntitiesData : [];
            const ship = data.find(e => e && (e.type === 'ship' || e.entityType === 'ship')) || null;
            const allowed = new Set(['box', 'capsule', 'cone', 'cylinder', 'plane', 'sphere']);
            if (!ship) {
                return { primitive: 'box', color: '#ffffff', scale: [2, 1, 3], updlId: null };
            }
            let primitive = (ship.visual && (ship.visual.model || ship.visual.primitive)) || 'box';
            if (!allowed.has(primitive) || primitive === 'default') primitive = 'box';
            const color = (ship.visual && ship.visual.color) || '#ffffff';
            const scale = Array.isArray(ship.transform?.scale) && ship.transform.scale.length === 3
                ? ship.transform.scale
                : [
                    ship.scale?.x || 2,
                    ship.scale?.y || 1,
                    ship.scale?.z || 3
                ];
            if (DEBUG_MP || (typeof window !== 'undefined' && window.DEBUG_RENDER)) {
                console.log('[Multiplayer] Player ship visual resolved:', { primitive, color, scale, updlId: ship?.id || null });
            }
            return { primitive, color, scale, updlId: ship.id || null };
        }

        function applyShipVisual(entity, visual) {
            try {
                if (!entity.model) {
                    const allowed = new Set(['box', 'capsule', 'cone', 'cylinder', 'plane', 'sphere']);
                    const type = (visual.primitive && allowed.has(visual.primitive)) ? visual.primitive : 'box';
                    entity.addComponent('model', { type });
                }
                const col = new pc.Color();
                col.fromString(visual.color || '#ffffff');
                const mat = new pc.StandardMaterial();
                mat.diffuse = col;
                mat.update();
                if (DEBUG_MP || (typeof window !== 'undefined' && window.DEBUG_RENDER)) {
                    console.log('[Multiplayer] Applying ship visual color:', visual.color || '#ffffff');
                }
                if (entity.model) {
                    entity.model.material = mat;
                    if (entity.model.meshInstances) {
                        entity.model.meshInstances.forEach(mi => mi.material = mat);
                    }
                }
                if (Array.isArray(visual.scale) && visual.scale.length === 3) {
                    entity.setLocalScale(visual.scale[0], visual.scale[1], visual.scale[2]);
                }
                // Prevent generateInlineShipLogic from overwriting material
                entity.__hasRenderComponent = true;
            } catch (e) {
                console.warn('[Multiplayer] Failed to apply ship visual:', e);
            }
        }

        function hideStaticUPDLShip(updlId) {
            try {
                if (!updlId || !window.MMOEntities) return;
                const existing = window.MMOEntities.get(updlId);
                if (existing) {
                    existing.enabled = false;
                    if (typeof existing.destroy === 'function') existing.destroy();
                    window.MMOEntities.delete(updlId);
                    if (DEBUG_MP) console.log('[Multiplayer] Hiding static UPDL ship:', updlId);
                }
            } catch (e) {
                console.warn('[Multiplayer] Failed to hide static UPDL ship:', e);
            }
        }

        function getFirstUPDLShipEntityId() {
            const data = Array.isArray(window.networkEntitiesData) ? window.networkEntitiesData : [];
            const ship = data.find(e => e && (e.type === 'ship' || e.entityType === 'ship')) || null;
            return ship?.id || null;
        }

        function adoptUPDLShipAsLocal() {
            try {
                const updlId = getFirstUPDLShipEntityId();
                if (!updlId || !window.MMOEntities) return null;
                const updlEntity = window.MMOEntities.get(updlId);
                if (!updlEntity) return null;
                // Ensure entity has ship logic; SP handlers should have attached it already
                return updlEntity;
            } catch (e) {
                console.warn('[Multiplayer] Failed to adopt UPDL ship as local:', e);
                return null;
            }
        }

        function getBaseUPDLShipEntity() {
            const updlId = getFirstUPDLShipEntityId();
            if (!updlId || !window.MMOEntities) return null;
            return window.MMOEntities.get(updlId) || null;
        }

        function createRemoteShipFromUPDLTemplate(sessionId, player) {
            try {
                const base = getBaseUPDLShipEntity();
                if (!base) return null;
                const clone = base.clone();
                clone.name = 'player_' + sessionId;
                // Place clone at provided position
                clone.setPosition(player.x || 0, player.y || 0, player.z || 0);
                // Remove local-only behaviors/components
                if (clone.rigidbody) {
                    try { clone.removeComponent('rigidbody'); } catch (_) {}
                }
                try { if (clone.shipController) delete clone.shipController; } catch (_) {}
                try { if (clone.laserSystem) delete clone.laserSystem; } catch (_) {}
                // Do not assign as window.playerShip; keep visual-only
                app.root.addChild(clone);
                return clone;
            } catch (err) {
                console.warn('[Multiplayer] Failed to clone UPDL ship template for remote:', err);
                return null;
            }
        }

        function setupColyseusHandlers() {
            // Robust attach with guard for initial state arrival
            let attached = false;

            const tryAttach = () => {
                if (!room || !room.state || !room.state.players || attached) return;
                attached = true;

                // Player management using Colyseus 0.16.x API
                // IMPORTANT: MapSchema.onChange may not fire on child property updates.
                // Attach per-player onChange inside onAdd to receive movement updates.
                room.state.players.onAdd = (player, sessionId) => {
                    console.log('[Multiplayer] Player joined:', sessionId, player.name);
                    createPlayerEntity(sessionId, player);
                    try {
                        player.onChange = () => {
                            if (DEBUG_MP && Math.random() < 0.05) console.log('[Multiplayer] player.onChange:', sessionId, { x: player.x, y: player.y, z: player.z });
                            updatePlayerEntity(sessionId, player);
                        };
                    } catch (e) {
                        console.warn('[Multiplayer] Failed to attach player.onChange listener:', e);
                    }
                };

                // Keep MapSchema-level onChange as a fallback when whole item replaced
                room.state.players.onChange = (player, sessionId) => {
                    if (DEBUG_MP && Math.random() < 0.05) console.log('[Multiplayer] players.onChange:', sessionId);
                    updatePlayerEntity(sessionId, player);
                };

                room.state.players.onRemove = (player, sessionId) => {
                    console.log('[Multiplayer] Player left:', sessionId);
                    removePlayerEntity(sessionId);
                };

                // Rehydrate already present players to ensure visibility of existing clients
                try {
                    if (room.state.players && typeof room.state.players.forEach === 'function') {
                        const presentIds = [];
                        room.state.players.forEach((player, sessionId) => {
                            presentIds.push(sessionId);
                            if (!window.networkPlayers || !window.networkPlayers.has(sessionId)) {
                                createPlayerEntity(sessionId, player);
                            }
                            // Ensure per-player onChange is attached for rehydrated players
                            try { player.onChange = () => updatePlayerEntity(sessionId, player); } catch (_) {}
                        });
                        if (DEBUG_MP) console.log('[Multiplayer] Rehydrated players:', presentIds);
                    }
                } catch (e) {
                    console.warn('[Multiplayer] Players rehydration failed:', e);
                }

                // Aggregate non-player entities from multiple maps (server exposes asteroids/stations/gates)
                attachEntityMapHandlers(room.state.asteroids, 'asteroid');
                attachEntityMapHandlers(room.state.stations, 'station');
                attachEntityMapHandlers(room.state.gates, 'gate');

                // Room events
                room.onMessage('*', (type, message) => {
                    // console.log('[Multiplayer] Message received:', type, message);
                    handleRoomMessage(type, message);
                });

                room.onLeave((code) => {
                    console.log('[Multiplayer] Left room with code:', code);
                });

                room.onError((code, message) => {
                    console.error('[Multiplayer] Room error:', code, message);
                });

                // Fallback: observe full state changes to ensure remote movement visibility
                if (typeof room.onStateChange === 'function') {
                    room.onStateChange((state) => {
                        try {
                            state.players.forEach((p, id) => {
                                if (!window.networkPlayers || !window.networkPlayers.has(id)) {
                                    createPlayerEntity(id, p);
                                }
                                if (id !== localPlayerId) updatePlayerEntity(id, p);
                            });
                        } catch (e) {
                            // Silent fallback
                        }
                    });
                }
            };

            // Attempt immediately
            tryAttach();
            // Fallback: wait for first state change
            if (!attached && room && typeof room.onStateChange === 'function') {
                room.onStateChange(function () {
                    tryAttach();
                });
            }
            // Last resort: slight delay
            setTimeout(tryAttach, 250);
        }

        // Safely initialize SpaceControls only once
        function safeInitSpaceControls() {
            if (SPACE_CONTROLS_INITIATED) return;
            if (typeof initializeSpaceControls === 'function') {
                try {
                    initializeSpaceControls();
                    SPACE_CONTROLS_INITIATED = true;
                    console.log('[Multiplayer] SpaceControls initialized after server connection');
                } catch (e) {
                    console.warn('[Multiplayer] initializeSpaceControls failed:', e);
                }
            }
        }

        function createPlayerEntity(sessionId, player) {
            // Create or adopt player ship entity
            if (!window.networkPlayers) window.networkPlayers = new Map();
            if (window.networkPlayers.has(sessionId)) return window.networkPlayers.get(sessionId);

            // Local player: adopt the first UPDL ship entity instead of creating new
            if (sessionId === localPlayerId) {
                const adopted = adoptUPDLShipAsLocal();
                if (adopted) {
                    // Store and setup
                    window.networkPlayers.set(sessionId, adopted);
                    setupLocalPlayerShip(adopted);
                    if (DEBUG_MP) console.log('[Multiplayer] Adopted UPDL ship as local player entity');
                    return adopted;
                }
            }

            // Remote players (or fallback): clone from UPDL template; if missing, create simplified entity
            let playerEntity = createRemoteShipFromUPDLTemplate(sessionId, player);
            if (!playerEntity) {
                playerEntity = new pc.Entity('player_' + sessionId);
                const entity = playerEntity;
                const spawnPoint = window.playerSpawnPoint || { position: [0, 0, 0] };
                playerEntity.setPosition(
                    player.x || spawnPoint.position[0],
                    player.y || spawnPoint.position[1],
                    player.z || spawnPoint.position[2]
                );
                const visual = getPlayerShipVisual();
                applyShipVisual(playerEntity, visual);
                app.root.addChild(playerEntity);
                // Do NOT attach ship logic to remote clones
            }

            // Store reference
            window.networkPlayers.set(sessionId, playerEntity);

            // If this is the local player, setup as player ship and initialize controls
            if (sessionId === localPlayerId) {
                // This path will happen only if adoption failed; setup local control
                setupLocalPlayerShip(playerEntity);
            }
            if (DEBUG_MP) console.log('[Multiplayer] createPlayerEntity:', { sessionId, localPlayerId, isLocal: sessionId === localPlayerId });
        }

        function updatePlayerEntity(sessionId, player) {
            // Skip applying server updates to local player to avoid jitter
            if (sessionId === localPlayerId) return;
            if (window.networkPlayers && window.networkPlayers.has(sessionId)) {
                const entity = window.networkPlayers.get(sessionId);
                
                // Update position (smooth interpolation could be added here)
                if (player.x !== undefined && player.y !== undefined && player.z !== undefined) {
                    entity.setPosition(player.x, player.y, player.z);
                }
                
                // Update rotation
                // Server uses rx, ry, rz in PlayerSchema
                if (player.rx !== undefined && player.ry !== undefined && player.rz !== undefined) {
                    entity.setEulerAngles(player.rx, player.ry, player.rz);
                }
                if (DEBUG_MP && Math.random() < 0.05) console.log('[Multiplayer] updatePlayerEntity applied:', sessionId);
            }
        }

        function removePlayerEntity(sessionId) {
            if (window.networkPlayers && window.networkPlayers.has(sessionId)) {
                const entity = window.networkPlayers.get(sessionId);
                entity.destroy();
                window.networkPlayers.delete(sessionId);
            }
        }

        function createNetworkEntity(entityId, entity) {
            // Create networked entity from server state
            // This would handle stations, asteroids, etc.
            console.log('[Multiplayer] Creating network entity:', entityId, entity);
        }

        function updateNetworkEntity(entityId, entity) {
            // Update networked entity state
            // This handles position/state sync for non-player entities
        }

        function removeNetworkEntity(entityId) {
            // Remove networked entity
            console.log('[Multiplayer] Removing network entity:', entityId);
        }

        function setupLocalPlayerShip(playerEntity) {
            // Setup local player ship (same as SP)
            console.log('[Multiplayer] Setting up local player ship');
            
            // Assign as player ship (required for SpaceControls)
            window.playerShip = playerEntity;
            
            // Initialize camera controller if available
            if (playerEntity.cameraController) {
                playerEntity.cameraController.target = playerEntity;
                playerEntity.cameraController.initializeCamera();
                console.log('[Multiplayer] Camera controller initialized for local player');
            } else if (window.spaceCamera) {
                // Fallback camera positioning
                window.spaceCamera.lookAt(playerEntity.getPosition());
                console.log('[Multiplayer] Fallback camera positioning applied');
            }
            
            // Initialize SpaceControls for local player (only after connection), guarded
            if (window.SpaceControls && !window.SpaceControls._initialized && !SPACE_CONTROLS_INITIATED) {
                try {
                    window.SpaceControls.init();
                    SPACE_CONTROLS_INITIATED = true;
                    console.log('[Multiplayer] SpaceControls initialized for local player');
                } catch (e) {
                    console.warn('[Multiplayer] SpaceControls init failed:', e);
                }
            }
            
            // Setup network synchronization for local player movement
            setupNetworkSync(playerEntity);
        }

        function setupNetworkSync(playerEntity) {
            // Network synchronization for local player (throttled updates)
            let lastSent = 0;
            const syncRate = 50; // ~20 Hz
            
            // Ensure we don't duplicate update handlers on reconnect
            if (networkUpdateHandler) {
                try { app.off('update', networkUpdateHandler); } catch (e) { /* noop */ }
            }

            networkUpdateHandler = (dt) => {
                if (!room || !window.playerShip || playerEntity !== window.playerShip) return;
                
                const now = Date.now();
                if (now - lastSent < syncRate) return;
                
                const pos = playerEntity.getPosition();
                const rot = playerEntity.getLocalEulerAngles();
                
                // Send transform update to server
                room.send('updateTransform', {
                    x: pos.x,
                    y: pos.y,
                    z: pos.z,
                    rx: rot.x,
                    ry: rot.y,
                    rz: rot.z
                });
                
                lastSent = now;
                if (DEBUG_MP && Math.random() < 0.05) console.log('[Multiplayer] sent updateTransform', { pos: { x: pos.x, y: pos.y, z: pos.z } });
            };
            app.on('update', networkUpdateHandler);
            
            console.log('[Multiplayer] Network synchronization setup complete');
        }

        function handleRoomMessage(type, message) {
            switch(type) {
                case 'player_action':
                    console.log('[Multiplayer] Player action:', message);
                    break;
                case 'world_event':
                    console.log('[Multiplayer] World event:', message);
                    break;
                default:
                    console.log('[Multiplayer] Unknown message type:', type);
            }
        }

        // Generic MapSchema attachment for non-player entities with rehydration
        function attachEntityMapHandlers(mapSchema, kind) {
            if (!mapSchema) return;

            mapSchema.onAdd = (entity, entityId) => {
                console.log('[Multiplayer] Entity added:', kind, entityId);
                createNetworkEntity(entityId, entity, kind);
            };
            mapSchema.onChange = (entity, entityId) => {
                updateNetworkEntity(entityId, entity, kind);
            };
            mapSchema.onRemove = (_entity, entityId) => {
                console.log('[Multiplayer] Entity removed:', kind, entityId);
                removeNetworkEntity(entityId, kind);
            };

            // Rehydrate existing entities
            try {
                if (typeof mapSchema.forEach === 'function') {
                    mapSchema.forEach((ent, id) => createNetworkEntity(id, ent, kind));
                }
            } catch (e) {
                console.warn('[Multiplayer] Entities rehydration failed for', kind, e);
            }
        }
        `
    }

    /**
     * Create multiplayer-specific systems manager
     * Disables automatic SpaceControls initialization to prevent controls before connection
     */
    private createMultiplayerSystemsManager() {
        // Use the standard systems manager for now
        // We'll handle SpaceControls initialization manually in the Colyseus connection logic
        return createMMOOMMBuilderSystemsManager()


    }

    /**
     * Generate inline ship logic for multiplayer player entities
     * Reuses the same ship generation logic as SP but inline
     */
    private generateInlineShipLogic(): string {
        // Generate ship logic and adapt for inline use in MP
        const shipLogic = generateShipLogic('inline_player_ship')

        // Remove entity variable references and adapt for direct use
        return shipLogic
            .replace(/entity\./g, 'playerEntity.')
            .replace(/console\.log\('\[Ship\]/g, 'console.log(\'[Multiplayer Ship]')
            .replace(/console\.log\(/g, 'if (window && window.DEBUG_MULTIPLAYER) console.log(')
    }



    /**
     * Wrap script with HTML structure including auth screen (fallback)
     */
    private wrapWithHTML(script: string, options: BuildOptions, authScreenHTML: string): string {
        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Universo MMOOMM - Multiplayer</title>
    <meta name="description" content="Multiplayer 3D space created with Universo Platformo">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
    </style>
    <script src="https://code.playcanvas.com/playcanvas-stable.min.js"></script>
    <script src="https://unpkg.com/colyseus.js@0.16.4/dist/colyseus.js"></script>
</head>
<body>
    <canvas id="application-canvas"></canvas>
    ${authScreenHTML}
    <script>
        // Initialize PlayCanvas application
        const canvas = document.getElementById('application-canvas');
        const app = new pc.Application(canvas, {
            mouse: new pc.Mouse(canvas),
            keyboard: new pc.Keyboard(window),
            touch: new pc.TouchDevice(canvas)
        });

        // Set canvas to fill window and automatically resize
        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
        app.setCanvasResolution(pc.RESOLUTION_AUTO);

        // Resize handler
        window.addEventListener('resize', () => app.resizeCanvas());

        ${script}

        // Start the application
        app.start();
    </script>
</body>
</html>`
    }
}
