// Universo Platformo | PlayCanvas MMOOMM Builder
// Advanced MMO template builder with full handler system

import { AbstractTemplateBuilder } from '../../../common/AbstractTemplateBuilder'
import { BuildOptions, TemplateConfig } from '../../../common/types'
import type { IFlowData, IUPDLMultiScene } from '@universo/publish-srv'
import { MMOOMMTemplateConfig } from './config'
import { SpaceHandler, EntityHandler, ComponentHandler, EventHandler, ActionHandler, DataHandler, UniversoHandler } from './handlers'
import { getDefaultRotatorScript, setupScriptSystem } from './scripts'

export class PlayCanvasMMOOMMBuilder extends AbstractTemplateBuilder {
    private spaceHandler = new SpaceHandler()
    private entityHandler = new EntityHandler()
    private componentHandler = new ComponentHandler()
    private eventHandler = new EventHandler()
    private actionHandler = new ActionHandler()
    private dataHandler = new DataHandler()
    private universoHandler = new UniversoHandler()

    constructor() {
        super('mmoomm')

        // Initialize script system for MMOOMM template
        setupScriptSystem()
    }

    /**
     * Build PlayCanvas MMOOMM HTML from flow data
     */
    async build(flowData: IFlowData, options: BuildOptions = {}): Promise<string> {
        console.log('[PlayCanvasMMOOMMBuilder] Building MMOOMM project')

        try {
            // Single scene processing
            if (flowData.updlSpace && !flowData.multiScene) {
                console.log('[PlayCanvasMMOOMMBuilder] Building single scene MMOOMM')
                const nodes = this.extractMMOOMMNodes(flowData)

                // Check if we have only Space node with no other content
                const hasContent =
                    nodes.entities.length > 0 ||
                    nodes.components.length > 0 ||
                    nodes.events.length > 0 ||
                    nodes.actions.length > 0 ||
                    nodes.data.length > 0 ||
                    nodes.universo.length > 0

                if (!hasContent) {
                    console.log('[PlayCanvasMMOOMMBuilder] Only Space node found, generating default red box scene')
                    return this.generateDefaultScene(options)
                }

                return this.buildSingleScene(flowData, options)
            }

            // Multi-scene processing
            if (flowData.multiScene) {
                console.log('[PlayCanvasMMOOMMBuilder] Building multi-scene MMOOMM:', {
                    totalScenes: flowData.multiScene.totalScenes
                })
                return this.buildMultiScene(flowData.multiScene, options)
            }

            // Fallback - generate default scene with red box
            console.warn('[PlayCanvasMMOOMMBuilder] No updlSpace or multiScene, generating default scene')
            return this.generateDefaultScene(options)
        } catch (error) {
            console.error('[PlayCanvasMMOOMMBuilder] Build error:', error)
            return this.generateDefaultScene(options)
        }
    }

    /**
     * Build single scene MMOOMM
     */
    private buildSingleScene(flowData: IFlowData, options: BuildOptions): string {
        const nodes = this.extractMMOOMMNodes(flowData)

        console.log(`[PlayCanvasMMOOMMBuilder] Entities: ${nodes.entities.length}, Components: ${nodes.components.length}`)

        // Process all node types using handlers
        const spaceScript = this.spaceHandler.process(nodes.spaces[0], options)
        const entityScript = this.entityHandler.process(nodes.entities, options)
        const componentScript = this.componentHandler.process(nodes.components, options)
        const eventScript = this.eventHandler.process(nodes.events, options)
        const actionScript = this.actionHandler.process(nodes.actions, options)
        const dataScript = this.dataHandler.process(nodes.data, options)
        const universoScript = this.universoHandler.process(nodes.universo, options)

        // Combine all scripts into executable code
        const combinedScript = [
            '// PlayCanvas MMOOMM Scene - Generated by Universo Platformo',
            '// Multi-user virtual world with real-time synchronization',
            '',
            '// Initialize PlayCanvas engine',
            this.generatePlayCanvasInit(),
            '',
            '// MMO Space setup',
            spaceScript,
            '',
            '// Entities with MMO capabilities',
            entityScript,
            '',
            '// Real-time Events',
            eventScript,
            '',
            '// Network Actions',
            actionScript,
            '',
            '// Data synchronization',
            dataScript,
            '',
            '// Universo networking gateway',
            universoScript,
            '',
            '// ADDED: Debug app state before starting',
            'console.log("[MMOOMM] App state before start:", {',
            '    hasCanvas: !!document.getElementById("application-canvas"),',
            '    hasPhysics: !!app.systems.rigidbody,',
            '    physicsEnabled: app.systems.rigidbody?.enabled,',
            '    entitiesCount: app.root.children.length,',
            '    hasMMOEntities: !!window.MMOEntities,',
            '    mmoEntitiesCount: window.MMOEntities?.size || 0',
            '});',
            '',
            '// Start PlayCanvas application',
            'app.start();',
            '',
            '// Initialize MMO systems after app starts',
            'console.log("[MMOOMM] Setting up app start event listener");',
            'app.on("start", () => {',
            '    console.log("[MMOOMM] App start event fired");',
            '    ',
            '    // ADDED: Debug app state after start',
            '    console.log("[MMOOMM] App state after start:", {',
            '        running: app.running,',
            '        entitiesCount: app.root.children.length,',
            '        physicsWorld: !!app.systems.rigidbody.dynamicsWorld,',
            '        mmoEntitiesCount: window.MMOEntities?.size || 0',
            '    });',
            '    ',
            '    if (typeof initializeSpaceControls === "function") {',
            '        console.log("[MMOOMM] Calling initializeSpaceControls");',
            '        initializeSpaceControls();',
            '    } else {',
            '        console.log("[MMOOMM] initializeSpaceControls not found");',
            '    }',
            '    if (typeof startHUDUpdates === "function") startHUDUpdates();',
            '});',
            '',
            '// Also try to initialize immediately after a delay',
            'setTimeout(() => {',
            '    console.log("[MMOOMM] Timeout initialization attempt");',
            '    if (typeof initializeSpaceControls === "function") {',
            '        console.log("[MMOOMM] Calling initializeSpaceControls from timeout");',
            '        initializeSpaceControls();',
            '    }',
            '}, 1000);',
            '',
            'console.log("[MMOOMM] Virtual world initialized - ready for players");'
        ].join('\n')

        return this.generateMMOOMMDocument(combinedScript, options)
    }

    /**
     * Build multi-scene MMOOMM
     */
    private buildMultiScene(multiScene: IUPDLMultiScene, options: BuildOptions): string {
        // For multi-scene, we process each scene and combine them
        const scenes = multiScene.scenes || []
        const allEntities: any[] = []
        const allComponents: any[] = []
        const allEvents: any[] = []
        const allActions: any[] = []
        const allData: any[] = []
        const allUniverso: any[] = []

        // Collect nodes from all scenes
        scenes.forEach((scene) => {
            if (scene.spaceData) {
                allEntities.push(...(scene.spaceData.entities || []))
                allComponents.push(...(scene.spaceData.components || []))
                allEvents.push(...(scene.spaceData.events || []))
                allActions.push(...(scene.spaceData.actions || []))
                allData.push(...(scene.spaceData.data || []))
                allUniverso.push(...(scene.spaceData.universo || []))
            }
        })

        console.log(`[PlayCanvasMMOOMMBuilder] Multi-scene totals: entities ${allEntities.length}, components ${allComponents.length}`)

        // Process using handlers
        const spaceScript = this.spaceHandler.process({ data: { type: 'root', id: 'multi-scene' } }, options)
        const entityScript = this.entityHandler.process(allEntities, options)
        const componentScript = this.componentHandler.process(allComponents, options)
        const eventScript = this.eventHandler.process(allEvents, options)
        const actionScript = this.actionHandler.process(allActions, options)
        const dataScript = this.dataHandler.process(allData, options)
        const universoScript = this.universoHandler.process(allUniverso, options)

        // Combine multi-scene script
        const combinedScript = [
            '// PlayCanvas MMOOMM Multi-Scene - Generated by Universo Platformo',
            `// Total scenes: ${scenes.length}`,
            '',
            this.generatePlayCanvasInit(),
            '',
            spaceScript,
            entityScript,
            eventScript,
            actionScript,
            dataScript,
            universoScript,
            '',
            'app.start();',
            '',
            '// Initialize MMO systems after app starts',
            'console.log("[MMOOMM] Setting up app start event listener");',
            'app.on("start", () => {',
            '    console.log("[MMOOMM] App start event fired");',
            '    if (typeof initializeSpaceControls === "function") {',
            '        console.log("[MMOOMM] Calling initializeSpaceControls");',
            '        initializeSpaceControls();',
            '    } else {',
            '        console.log("[MMOOMM] initializeSpaceControls not found");',
            '    }',
            '    if (typeof startHUDUpdates === "function") startHUDUpdates();',
            '});',
            '',
            '// Also try to initialize immediately after a delay',
            'setTimeout(() => {',
            '    console.log("[MMOOMM] Timeout initialization attempt");',
            '    if (typeof initializeSpaceControls === "function") {',
            '        console.log("[MMOOMM] Calling initializeSpaceControls from timeout");',
            '        initializeSpaceControls();',
            '    }',
            '}, 1000);',
            '',
            'console.log("[MMOOMM] Multi-scene virtual world initialized");'
        ].join('\n')

        return this.generateMMOOMMDocument(combinedScript, options)
    }

    /**
     * Generate PlayCanvas initialization code
     */
    private generatePlayCanvasInit(): string {
        return `
// Initialize PlayCanvas application with MMO support
const canvas = document.getElementById('application-canvas');
const app = new pc.Application(canvas, {
    mouse: new pc.Mouse(canvas),
    touch: new pc.TouchDevice(canvas),
    keyboard: new pc.Keyboard(window),
    elementInput: new pc.ElementInput(canvas)
});

// FIXED: Enable physics system with proper initialization
console.log('[MMOOMM] Enabling physics system...');
if (app.systems.rigidbody) {
    app.systems.rigidbody.enabled = true;

    // FIXED: Proper physics world initialization
    // The physics world is created automatically when the first rigidbody is added
    // We just need to ensure the system is enabled and gravity is set

    // Universo Platformo | Space physics setup - no gravity for space environment
    app.systems.rigidbody.gravity.set(0, 0, 0);
    console.log('[MMOOMM] Physics system enabled with zero gravity for space');

    // Add debug info about physics state
    setTimeout(() => {
        console.log('[MMOOMM] Physics world state:', {
            enabled: app.systems.rigidbody.enabled,
            hasWorld: !!app.systems.rigidbody.dynamicsWorld,
            gravity: app.systems.rigidbody.gravity.toString()
        });
    }, 100);
} else {
    console.error('[MMOOMM] Physics system not found!');
}

// Configure application for MMO
app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
app.setCanvasResolution(pc.RESOLUTION_AUTO);
window.addEventListener('resize', () => app.resizeCanvas());

// Basic lighting for the MMO world
const ambientLight = new pc.Entity('ambient');
ambientLight.addComponent('light', {
    type: pc.LIGHTTYPE_DIRECTIONAL,
    color: new pc.Color(1, 1, 1),
    intensity: 1.2 // Increased intensity for better visibility
});
ambientLight.setLocalEulerAngles(45, 30, 0);
app.root.addChild(ambientLight);

// Add additional ambient light for space environment
const spaceAmbient = new pc.Entity('space-ambient');
spaceAmbient.addComponent('light', {
    type: pc.LIGHTTYPE_DIRECTIONAL,
    color: new pc.Color(0.8, 0.9, 1), // Slightly blue tint
    intensity: 0.6
});
spaceAmbient.setLocalEulerAngles(-45, -30, 0); // Opposite direction
app.root.addChild(spaceAmbient);

// Universo Platformo | Space camera setup
const camera = new pc.Entity('camera');
camera.addComponent('camera', {
    clearColor: new pc.Color(0.02, 0.02, 0.1), // Deep space black-blue
    fov: 75, // Wider field of view for space
    nearClip: 0.1,
    farClip: 5000 // Much larger far clip for space
});

// IMPROVED: Start camera at default position (will be overridden by ship camera controller)
camera.setLocalPosition(0, 10, 15); // Position behind expected ship location (positive Z)
camera.lookAt(0, 2, 0); // Look at expected ship position
app.root.addChild(camera);

// Store camera reference for ship following
window.spaceCamera = camera;

// ADDED: Debug camera position
console.log('[MMOOMM] Camera initialized at position:', camera.getPosition().toString());

// Make app globally available
window.app = app;
`
    }

    /**
     * Extract MMOOMM-specific nodes from flow data
     */
    private extractMMOOMMNodes(flowData: IFlowData): {
        spaces: any[]
        entities: any[]
        components: any[]
        events: any[]
        actions: any[]
        data: any[]
        universo: any[]
    } {
        // Extract base nodes using parent method
        const baseNodes = this.extractNodes(flowData)

        const firstSpace = baseNodes.spaces[0] || {}

        return {
            spaces: baseNodes.spaces,
            entities: (firstSpace as any).entities || [],
            components: (firstSpace as any).components || [],
            events: (firstSpace as any).events || [],
            actions: (firstSpace as any).actions || [],
            data: baseNodes.data,
            universo: (firstSpace as any).universo || []
        }
    }

    /**
     * Generate MMOOMM-specific HTML document structure
     */
    private generateMMOOMMDocument(sceneScript: string, options: BuildOptions): string {
        const projectName = options.projectName || 'Universo MMOOMM Virtual World'
        const librarySources = this.getLibrarySourcesForTemplate(options)

        // Generate script tags for required libraries
        const libraryScripts = librarySources.map((src) => `    <script src="${src}"></script>`).join('\n')

        return `<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${projectName}</title>
    <meta name="description" content="PlayCanvas MMOOMM - Universo Platformo">
${libraryScripts}
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        /* Universo Platformo | Space MMO UI System */
        #space-hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            color: white;
            font-size: 14px;
        }

        .hud-panel {
            position: absolute;
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid rgba(0, 150, 255, 0.5);
            border-radius: 5px;
            padding: 10px;
            pointer-events: auto;
        }

        #ship-status {
            top: 10px;
            left: 10px;
            min-width: 200px;
        }

        #inventory-panel {
            top: 10px;
            right: 10px;
            min-width: 180px;
        }

        #trading-panel {
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            min-width: 300px;
            display: none;
        }

        #mini-map {
            bottom: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(0, 150, 255, 0.5);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            overflow: hidden;
            margin: 5px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            transition: width 0.3s ease;
        }

        .currency {
            color: #ffd700;
            font-weight: bold;
        }

        .item-list {
            max-height: 100px;
            overflow-y: auto;
            margin-top: 5px;
        }

        .item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls-hint {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }

        #application-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body>
    <!-- Universo Platformo | Space MMO HUD System -->
    <div id="space-hud">
        <!-- Ship Status Panel -->
        <div id="ship-status" class="hud-panel">
            <div><strong>Ship Status</strong></div>
            <div>Hull: <span id="ship-hull">100%</span></div>
            <div class="progress-bar">
                <div id="hull-bar" class="progress-fill" style="width: 100%"></div>
            </div>
            <div>Fuel: <span id="ship-fuel">100%</span></div>
            <div class="progress-bar">
                <div id="fuel-bar" class="progress-fill" style="width: 100%"></div>
            </div>
            <div>Currency: <span id="ship-currency" class="currency">0 Inmo</span></div>
            <div>World: <span id="current-world">Kubio</span></div>
        </div>

        <!-- Inventory Panel -->
        <div id="inventory-panel" class="hud-panel">
            <div><strong>Cargo Hold</strong></div>
            <div>Capacity: <span id="cargo-capacity">0/20 m³</span></div>
            <div class="progress-bar">
                <div id="cargo-bar" class="progress-fill" style="width: 0%"></div>
            </div>
            <div class="item-list" id="cargo-items">
                <div class="item">
                    <span>Empty</span>
                    <span>-</span>
                </div>
            </div>
        </div>

        <!-- Trading Panel (hidden by default) -->
        <div id="trading-panel" class="hud-panel">
            <div><strong>Trading Station</strong></div>
            <div id="station-name">Station Espero</div>
            <div>Price: <span id="trade-price">10 Inmo/ton</span></div>
            <div>
                <button id="trade-all-btn" onclick="tradeAll()">Trade All</button>
                <button id="trade-half-btn" onclick="tradeHalf()">Trade Half</button>
                <button id="close-trade-btn" onclick="closeTrade()">Close</button>
            </div>
        </div>

        <!-- Mini Map -->
        <div id="mini-map" class="hud-panel">
            <canvas id="mini-map-canvas" width="130" height="130"></canvas>
        </div>

        <!-- Controls Hint -->
        <div class="controls-hint">
            <div><strong>Controls:</strong></div>
            <div>WASD - Move Ship</div>
            <div>Space - Fire Weapon</div>
            <div>E - Interact/Trade</div>
            <div>M - Toggle Map</div>
        </div>
    </div>

    <canvas id="application-canvas"></canvas>
    
    <script>
        // Universo Platformo | Space MMO HUD System
        window.SpaceHUD = {
            // Update ship status display
            updateShipStatus(ship) {
                if (!ship) return;

                // Update currency
                const currency = ship.currency || 0;
                document.getElementById('ship-currency').textContent = currency + ' Inmo';

                // Update inventory
                if (ship.inventory) {
                    const capacity = ship.inventory.getCapacityInfo();
                    document.getElementById('cargo-capacity').textContent =
                        capacity.current.toFixed(1) + '/' + capacity.max + ' m³';
                    document.getElementById('cargo-bar').style.width = capacity.percentage + '%';

                    // Update item list
                    const itemsContainer = document.getElementById('cargo-items');
                    const items = ship.inventory.getItemList();

                    if (items.length === 0) {
                        itemsContainer.innerHTML = '<div class="item"><span>Empty</span><span>-</span></div>';
                    } else {
                        itemsContainer.innerHTML = items.map(item =>
                            '<div class="item"><span>' + item.type + '</span><span>' + item.amount.toFixed(1) + '</span></div>'
                        ).join('');
                    }
                }

                // Update laser system status
                if (ship.laserSystem) {
                    const status = ship.laserSystem.getStatus();
                    let statusText = '';
                    let statusColor = '#00ff00';

                    switch (status.state) {
                        case 'idle':
                            statusText = 'Ready';
                            statusColor = '#00ff00';
                            break;
                        case 'targeting':
                            statusText = 'Targeting...';
                            statusColor = '#ffff00';
                            break;
                        case 'mining':
                            const progress = Math.round(status.progress * 100);
                            statusText = 'Mining ' + progress + '%';
                            statusColor = '#ff6600';
                            break;
                        case 'collecting':
                            statusText = 'Collecting';
                            statusColor = '#00ffff';
                            break;
                        default:
                            statusText = status.state;
                            statusColor = '#ffffff';
                    }

                    // Update laser status display (create if doesn't exist)
                    let laserStatus = document.getElementById('laser-status');
                    if (!laserStatus) {
                        laserStatus = document.createElement('div');
                        laserStatus.id = 'laser-status';
                        laserStatus.style.cssText = 'position: absolute; top: 120px; left: 10px; color: white; font-family: monospace; font-size: 12px; background: rgba(0,0,0,0.7); padding: 5px; border-radius: 3px;';
                        document.body.appendChild(laserStatus);
                    }

                    laserStatus.innerHTML = '<span style="color: ' + statusColor + '">Laser: ' + statusText + '</span>';

                    if (status.hasTarget && status.targetDistance !== null) {
                        laserStatus.innerHTML += '<br><span style="color: #cccccc">Range: ' + status.targetDistance.toFixed(1) + 'u</span>';
                    }
                }
            },

            // Show trading panel
            showTradingPanel(stationInfo) {
                const panel = document.getElementById('trading-panel');
                panel.style.display = 'block';

                document.getElementById('station-name').textContent = stationInfo.stationName || 'Trading Station';
                document.getElementById('trade-price').textContent = (stationInfo.pricePerTon || 10) + ' Inmo/ton';
            },

            // Hide trading panel
            hideTradingPanel() {
                document.getElementById('trading-panel').style.display = 'none';
            },

            // Update mini map
            updateMiniMap(entities) {
                const canvas = document.getElementById('mini-map-canvas');
                const ctx = canvas.getContext('2d');

                // Clear canvas
                ctx.fillStyle = 'rgba(0, 0, 20, 1)';
                ctx.fillRect(0, 0, 130, 130);

                // Draw grid
                ctx.strokeStyle = 'rgba(0, 150, 255, 0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 130; i += 26) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, 130);
                    ctx.moveTo(0, i);
                    ctx.lineTo(130, i);
                    ctx.stroke();
                }

                // Draw entities
                if (window.MMOEntities) {
                    window.MMOEntities.forEach((entity, id) => {
                        const pos = entity.getPosition();
                        const x = 65 + pos.x * 2; // Scale and center
                        const y = 65 + pos.z * 2;

                        if (x >= 0 && x <= 130 && y >= 0 && y <= 130) {
                            if (entity.shipController) {
                                // Player ship - green
                                ctx.fillStyle = '#00ff00';
                                ctx.fillRect(x-2, y-2, 4, 4);
                            } else if (entity.tradingPost) {
                                // Station - blue
                                ctx.fillStyle = '#0080ff';
                                ctx.fillRect(x-3, y-3, 6, 6);
                            } else if (entity.mineable) {
                                // Asteroid - gray
                                ctx.fillStyle = '#888888';
                                ctx.fillRect(x-1, y-1, 2, 2);
                            } else if (entity.portal) {
                                // Gate - yellow
                                ctx.fillStyle = '#ffff00';
                                ctx.fillRect(x-2, y-2, 4, 4);
                            }
                        }
                    });
                }
            },

            // Update world name
            updateWorld(worldName) {
                document.getElementById('current-world').textContent = worldName || 'Unknown';
                window.currentWorld = worldName;
            }
        };

        // Trading functions
        function tradeAll() {
            const ship = window.playerShip;
            const station = ship?.nearStation;

            if (ship && station && ship.inventory) {
                const items = ship.inventory.getItemList();
                items.forEach(item => {
                    if (item.type === 'asteroidMass') {
                        station.tradingPost.trade(ship, item.type, item.amount);
                    }
                });
                window.SpaceHUD.updateShipStatus(ship);
            }
        }

        function tradeHalf() {
            const ship = window.playerShip;
            const station = ship?.nearStation;

            if (ship && station && ship.inventory && ship.inventory.items.asteroidMass) {
                const amount = ship.inventory.items.asteroidMass / 2;
                station.tradingPost.trade(ship, 'asteroidMass', amount);
                window.SpaceHUD.updateShipStatus(ship);
            }
        }

        function closeTrade() {
            window.SpaceHUD.hideTradingPanel();
        }

        // Universo Platformo | Space ship controls and camera system
        window.SpaceControls = {
            keys: {},

            // Initialize input handling
            init() {
                console.log('[SpaceControls] Initializing input handling...');

                // Keyboard input
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;

                    // Handle special keys
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.fireWeapon();
                    } else if (e.code === 'KeyE') {
                        this.interact();
                    }
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                // ADDED: Mouse wheel for camera zoom
                window.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.handleCameraZoom(e.deltaY);
                });

                // Update loop
                app.on('update', (dt) => {
                    this.updateShipMovement(dt);
                    this.updateCamera(dt);
                });

                console.log('[SpaceControls] Input handling initialized successfully');

                // ADDED: Display control instructions
                this.showControlInstructions();
            },

            // IMPROVED: New ship movement system with rotation-based controls
            updateShipMovement(dt) {
                const ship = window.playerShip;
                if (!ship || !ship.shipController) {
                    return;
                }

                const controller = ship.shipController;
                let hasInput = false;

                // Check for Shift modifier (for strafe mode)
                const isShiftPressed = this.keys['ShiftLeft'] || this.keys['ShiftRight'];

                // NEW: Thrust controls (W/S for forward/backward)
                let thrustForward = false;
                let thrustBackward = false;

                // Rotation flags
                let rotateUp = false;
                let rotateDown = false;
                let rotateLeft = false;
                let rotateRight = false;
                // Roll flags
                let rollLeft = false;   // E
                let rollRight = false;  // C

                // Strafe flags (Shift held)
                let strafeLeft = false;
                let strafeRight = false;
                let strafeUp = false;
                let strafeDown = false;

                if (this.keys['KeyW']) { thrustForward = true; hasInput = true; }
                if (this.keys['KeyS']) { thrustBackward = true; hasInput = true; }

                if (isShiftPressed) {
                    // SHIFT + WASD = Strafe movement (no rotation)
                    if (this.keys['KeyA']) { strafeLeft = true; hasInput = true; }
                    if (this.keys['KeyD']) { strafeRight = true; hasInput = true; }
                    if (this.keys['KeyQ']) { strafeUp = true; hasInput = true; }
                    if (this.keys['KeyZ']) { strafeDown = true; hasInput = true; }
                } else {
                    // Normal mode: QAZD = Rotation + Roll (E/C)
                    if (this.keys['KeyQ']) { rotateUp = true; hasInput = true; }
                    if (this.keys['KeyZ']) { rotateDown = true; hasInput = true; }
                    if (this.keys['KeyA']) { rotateLeft = true; hasInput = true; }
                    if (this.keys['KeyD']) { rotateRight = true; hasInput = true; }
                    if (this.keys['KeyE']) { rollLeft = true; hasInput = true; }
                    if (this.keys['KeyC']) { rollRight = true; hasInput = true; }
                }

                // LEGACY: Arrow keys still work for rotation (backup)
                if (this.keys['ArrowUp']) { rotateUp = true; hasInput = true; }
                if (this.keys['ArrowDown']) { rotateDown = true; hasInput = true; }
                if (this.keys['ArrowLeft']) { rotateLeft = true; hasInput = true; }
                if (this.keys['ArrowRight']) { rotateRight = true; hasInput = true; }

                // Apply thrust (forward/backward along ship's nose direction)
                if (thrustForward) {
                    // W = fly forward (toward ship's nose)
                    const forward = ship.forward.clone().scale(-1);
                    controller.thrust(forward);
                } else if (thrustBackward) {
                    // S = fly backward (reverse)
                    const backward = ship.forward.clone().scale(0.7);
                    controller.thrust(backward);
                } else if (strafeLeft || strafeRight || strafeUp || strafeDown) {
                    // STRAFE: Shift + WASD/QZ moves ship sideways/up/down using maneuver thrusters
                    const strafeVector = new pc.Vec3();
                    if (strafeLeft)  strafeVector.x += 1;  // Shift+A  → left (local -X wing)
                    if (strafeRight) strafeVector.x -= 1;  // Shift+D  → right
                    if (strafeUp)    strafeVector.y += 1;  // Shift+Q  → up
                    if (strafeDown)  strafeVector.y -= 1;  // Shift+Z  → down

                    // Convert from local to world based on current ship orientation
                    const worldStrafe = ship.getRotation().transformVector(strafeVector.normalize());
                    controller.thrust(worldStrafe.scale(0.8)); // Maneuver thrusters weaker
                } else {
                    controller.stopThrust();
                }

                // FIXED: Apply rotation with correct directions for camera-behind-ship setup
                const rotationVector = new pc.Vec3();

                // Pitch (up/down rotation around X-axis) - FIXED directions
                if (rotateUp) rotationVector.x += 1;    // Q = positive X rotation (nose up)
                if (rotateDown) rotationVector.x -= 1;  // Z = negative X rotation (nose down)

                // Yaw (left/right rotation around Y-axis) - FIXED directions
                if (rotateLeft) rotationVector.y += 1;  // A = positive Y rotation (turn left)
                if (rotateRight) rotationVector.y -= 1; // D = negative Y rotation (turn right)

                // Roll mapping
                if (rollLeft)  rotationVector.z += 1;   // E = roll left (counter-clockwise)
                if (rollRight) rotationVector.z -= 1;   // C = roll right (clockwise)

                // Apply rotation if any rotation input detected
                if (rotationVector.length() > 0) {
                    // Normalize for consistent speed in diagonal movements
                    rotationVector.normalize();
                    controller.rotate(rotationVector, dt);

                    // Debug: Log combination inputs occasionally
                    if (Math.random() < 0.01) {
                        const combinations = [];
                        if (rotateUp) combinations.push('UP');
                        if (rotateDown) combinations.push('DOWN');
                        if (rotateLeft) combinations.push('LEFT');
                        if (rotateRight) combinations.push('RIGHT');
                        if (combinations.length > 1) {
                            console.log('[SpaceControls] Combination rotation:', combinations.join('+'));
                        }
                    }
                }

                // Debug logging (rare)
                if (hasInput && Math.random() < 0.001) {
                    const mode = isShiftPressed ? 'STRAFE' : 'ROTATION';
                    console.log('[SpaceControls] Control mode: ' + mode);
                }
            },

            // ADDED: Show control instructions to user
            showControlInstructions() {
                console.log('');
                console.log('🚀 UNIVERSO PLATFORMO - SPACE CONTROLS 🚀');
                console.log('==========================================');
                console.log('📋 BASIC CONTROLS:');
                console.log('  W/S     - Thrust Forward/Backward');
                console.log('  Q/Z     - Rotate Up/Down (Pitch)');
                console.log('  A/D     - Rotate Left/Right (Yaw)');
                console.log('  Mouse   - Wheel to Zoom Camera');
                console.log('  Space   - Fire Weapon');
                console.log('  E       - Interact');
                console.log('');
                console.log('🎮 ADVANCED CONTROLS:');
                console.log('  Shift+A/D/Q/Z - Strafe Movement');
                console.log('  Arrow Keys     - Alternative Rotation');
                console.log('');
                console.log('💡 TIPS:');
                console.log('  • Camera follows your ship automatically');
                console.log('  • Use combinations (Q+A) for diagonal turns');
                console.log('  • Zoom out to see more of the battlefield');
                console.log('==========================================');
                console.log('');
            },

            // IMPROVED: Camera controller with proper ship following
            updateCamera(dt) {
                const ship = window.playerShip;
                const camera = window.spaceCamera;

                if (!ship || !camera) return;

                // Use the new camera controller if available
                if (ship.cameraController) {
                    ship.cameraController.update(dt);
                } else {
                    // Fallback to basic following
                    this.basicCameraFollow(ship, camera, dt);
                }
            },

            // Basic camera following (fallback)
            basicCameraFollow(ship, camera, dt) {
                const shipPos = ship.getPosition();
                const targetPos = shipPos.clone().add(new pc.Vec3(0, 15, 25));
                const currentPos = camera.getPosition();

                // FIXED: Correct lerp usage
                const lerpFactor = Math.min(2 * dt, 1); // Clamp to prevent overshoot
                const newPos = currentPos.lerp(targetPos, lerpFactor);
                camera.setPosition(newPos);

                // Camera looks at ship
                camera.lookAt(shipPos);
            },

            // ADDED: Handle camera zoom with mouse wheel
            handleCameraZoom(deltaY) {
                const ship = window.playerShip;
                if (!ship || !ship.cameraController) return;

                // Zoom sensitivity
                const zoomSpeed = 2;
                const zoomDelta = deltaY > 0 ? zoomSpeed : -zoomSpeed;

                ship.cameraController.zoom(zoomDelta);

                // Optional: Log zoom level for debugging
                if (Math.random() < 0.1) { // Log occasionally to avoid spam
                    console.log('[Camera] Zoom distance:', ship.cameraController.distance.toFixed(1));
                }
            },

            // Activate laser mining system
            fireWeapon() {
                const ship = window.playerShip;
                if (ship && ship.laserSystem) {
                    const activated = ship.laserSystem.activate();
                    if (activated) {
                        console.log('[SpaceControls] Laser mining system activated');
                    } else {
                        console.log('[SpaceControls] Laser system busy or unavailable');
                    }
                } else {
                    console.warn('[SpaceControls] No laser system found on player ship');
                }
            },

            // Interact with nearby objects
            interact() {
                const ship = window.playerShip;
                if (ship && ship.nearStation) {
                    // Show trading panel
                    const tradingInfo = ship.nearStation.tradingPost.getTradingInfo();
                    window.SpaceHUD.showTradingPanel(tradingInfo);
                }
            }
        };

        // IMPROVED: Initialize physics for all entities after they are added to scene
        function initializePhysics() {
            console.log('[Space] Initializing physics for all entities...');

            if (!window.MMOEntities) {
                console.warn('[Space] No MMOEntities found');
                return;
            }

            // Wait for physics system to be ready
            if (!app || !app.systems || !app.systems.rigidbody) {
                console.error('[Space] Physics system not available!');
                return;
            }

            // Ensure physics system is enabled
            if (!app.systems.rigidbody.enabled) {
                app.systems.rigidbody.enabled = true;
                console.log('[Space] Physics system enabled');
            }

            console.log('[Space] Physics system state:', {
                enabled: app.systems.rigidbody.enabled,
                gravity: app.systems.rigidbody.gravity,
                hasWorld: !!app.systems.rigidbody.dynamicsWorld
            });

            let successCount = 0;
            let totalCount = 0;

            window.MMOEntities.forEach((entity, id) => {
                if (entity.rigidbody) {
                    totalCount++;
                    console.log('[Space] Initializing physics for entity:', id);

                    // FIXED: Force enable rigidbody and wait for next frame
                    entity.rigidbody.enabled = true;

                    // Use setTimeout to allow physics system to process
                    setTimeout(() => {
                        if (entity.rigidbody.body) {
                            console.log('[Space] Physics body created for', id);
                        } else {
                            console.warn('[Space] Physics body not created for', id, '- using fallback movement');
                        }
                    }, 100);

                    successCount++; // Count as success since we enabled it
                }
            });

            console.log('[Space] Physics initialization complete:', successCount, '/', totalCount, 'entities enabled');
        }

        // Initialize controls when app starts (moved after app.start())
        function initializeSpaceControls() {
            console.log('[Space] Initializing SpaceControls...');

            // Check if SpaceControls exists
            if (!window.SpaceControls) {
                console.error('[Space] SpaceControls not found!');
                return;
            }

            console.log('[Space] SpaceControls found, calling init()');
            window.SpaceControls.init();
            console.log('[Space] SpaceControls.init() completed');

            // Find player ship
            console.log('[Space] Looking for player ship...');

            if (window.MMOEntities) {
                console.log('[Space] Total entities found:', window.MMOEntities.size);

                window.MMOEntities.forEach((entity, id) => {
                    console.log('[Space] Entity', id, 'components:', {
                        hasModel: !!entity.model,
                        hasShipController: !!entity.shipController,
                        hasRigidbody: !!entity.rigidbody,
                        position: entity.getPosition().toString(),
                        visible: entity.enabled
                    });

                    if (entity.shipController) {
                        window.playerShip = entity;
                        console.log('[Space] Player ship found:', id);
                    }
                });
            }

            if (!window.playerShip) {
                console.warn('[Space] No player ship found! Check entity creation.');
            } else {
                console.log('[Space] Player ship successfully assigned at position:', window.playerShip.getPosition().toString());
            }

            // Initialize physics after a short delay to ensure scene is fully loaded
            setTimeout(() => {
                initializePhysics();
            }, 500);
        }

        // Update HUD every second (moved after app.start())
        function startHUDUpdates() {
            setInterval(() => {
                if (window.playerShip) {
                    window.SpaceHUD.updateShipStatus(window.playerShip);
                    window.SpaceHUD.updateMiniMap();
                }
            }, 1000);
        }

        ${sceneScript}
    </script>
</body>
</html>`
    }

    /**
     * Generate error scene for debugging
     */
    private generateErrorScene(options: BuildOptions): string {
        const demoMode = options.demoMode || 'off'

        if (demoMode === 'off') {
            // Empty scene with just camera and lighting
            const emptyScript = `
${this.generatePlayCanvasInit()}

// Empty scene - no demo objects
app.start();
console.log('[MMOOMM] Empty scene loaded - demo mode disabled');
`
            return this.generateMMOOMMDocument(emptyScript, options)
        } else if (demoMode === 'primitives') {
            // Scene with rotating red cube
            const demoScript = `
${this.generatePlayCanvasInit()}

// Default scene - red box indicating minimal MMOOMM setup
const defaultBox = new pc.Entity('default-box');
defaultBox.addComponent('model', { type: 'box' });

// Create red material
const material = new pc.StandardMaterial();
material.diffuse.set(1, 0, 0); // Red color
material.update();

defaultBox.model.material = material;
defaultBox.setLocalScale(2, 2, 2);
app.root.addChild(defaultBox);

// Add rotation script for smooth animation using new script system
${this.generateRotatorScriptCode()}

defaultBox.addComponent('script');
defaultBox.script.create('rotator');

app.start();
console.log('[MMOOMM] Demo scene loaded - rotating red cube displayed');
`
            return this.generateMMOOMMDocument(demoScript, options)
        }

        // Fallback - empty scene
        return this.generateErrorScene({ ...options, demoMode: 'off' })
    }

    /**
     * Generate rotator script code using the new script system
     */
    private generateRotatorScriptCode(): string {
        const rotatorScript = getDefaultRotatorScript()
        return rotatorScript.generateScript()
    }

    /**
     * Generate default scene with configurable demo mode (for empty flows)
     */
    private generateDefaultScene(options: BuildOptions): string {
        return this.generateErrorScene(options)
    }

    /**
     * Implementation of abstract method from AbstractTemplateBuilder
     */
    protected generateHTML(
        content: {
            spaceContent: string
            objectContent: string
            cameraContent: string
            lightContent: string
            dataContent: string
            template: string
            error?: boolean
        },
        options: BuildOptions = {}
    ): string {
        // This method is required by AbstractTemplateBuilder but not used in our implementation
        // We use build() method instead for more advanced processing
        return this.generateErrorScene(options)
    }

    /**
     * Get template configuration
     */
    getTemplateInfo(): TemplateConfig {
        return MMOOMMTemplateConfig
    }

    /**
     * Get required libraries for this template
     */
    getRequiredLibraries(): string[] {
        return ['playcanvas']
    }
}
